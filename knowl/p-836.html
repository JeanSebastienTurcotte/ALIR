<!DOCTYPE html>
<html lang="fr-CA" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<h6 class="heading"><span class="type">Paragraphe</span></h6>
<div class="para logical"><ol class="lower-alpha">
<li>
<div class="para">Pour trouver le vecteur normal <span class="process-math">\(\vec{n}\text{,}\)</span> il faut résoudre simultanément les équations <span class="process-math">\(\vec{u}\cdot\vec{n}=0\)</span> et <span class="process-math">\(\vec{v}\cdot\vec{n}=0\text{.}\)</span> Le code suivant permet d’obtenir une solution.</div>
<figure class="listing figure-like"><div class="code-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><pre class="program"><code class="language-py">u=vector([-1,2,1])  #le premier vecteur directeur
v=vector([-5,4,-3]) #le second vecteur directeur
var("a","b","c")
n=vector([a,b,c])  #le vecteur normal
eq1=u*n==0   #le vecteur normal doit être perpendiculaire à u
eq2=v*n==0   #le vecteur normal doit être perpendiculaire à v
sol=solve([eq1,eq2],a,b,c,solution_dict=True) #on résout les équations en fonction des composantes du vecteur normal. L'option solution_dict permet de coder différement les entrées de sol
sol
</code></pre></div>
<figcaption><span class="type">Bloc de code</span><span class="space"> </span><span class="codenumber">1.3.30<span class="period">.</span></span><span class="space"> </span>Le code pour le vecteur normal, partie 1</figcaption></figure><div class="para">À remarquer qu’il y a une infinité de solutions, données sous forme paramétrique ici. Ceci est attendu étant donné que n’importe quel multiple d’un vecteur normal est aussi un vecteur normal. Dans ce cas-ci, si l’on prend la variable libre comme étant égale à <span class="process-math">\(3\)</span> (pour éliminer les fractions), on obtient</div>
<figure class="listing figure-like"><div class="code-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><pre class="program"><code class="language-py">n=vector([sol[0][a],sol[0][b],sol[0][c]]) #on extrait de la liste de solutions sol les expressions voulues
libre=sol[0][a].variables()[0] #On va chercher le nom de la variable libre. Ceci est nécessaire au cas où des exécutions multiples sont effectuées
n=n.subs({libre:3})     #on pose la variable libre à 3
n
</code></pre></div>
<figcaption><span class="type">Bloc de code</span><span class="space"> </span><span class="codenumber">1.3.31<span class="period">.</span></span><span class="space"> </span>Le code pour le vecteur normal, partie 2</figcaption></figure><div class="para">Finalement, on obtient l’équation normale <span class="process-math">\(\vec{n}\cdot (x-6,y-3,z-2)=0\)</span> ce qui donne</div>
<figure class="listing figure-like"><div class="code-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><pre class="program"><code class="language-py">var("x","y","z")
show(n*vector([x-6,y-3,z-2])==0)
</code></pre></div>
<figcaption><span class="type">Bloc de code</span><span class="space"> </span><span class="codenumber">1.3.32<span class="period">.</span></span><span class="space"> </span>Le code pour l’équation normale</figcaption></figure>
</li>
<li>
<div class="para">La distance est obtenue à l’aide de la formule <span class="process-math">\(\|\vecl{AP}_{\vec{n}}\|\text{:}\)</span>
</div>
<figure class="listing figure-like"><div class="code-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><pre class="program"><code class="language-py">OA=vector([6,3,2]) #un point connu sur le plan
OP=vector([3,-4,2]) #le point extérieur au plan
AP=OP-OA
APsurn=AP*n/(n*n)*n  #calcul de la projection
show(norm(APsurn))
</code></pre></div>
<figcaption><span class="type">Bloc de code</span><span class="space"> </span><span class="codenumber">1.3.33<span class="period">.</span></span><span class="space"> </span>Le code pour la distance point plan</figcaption></figure>
</li>
<li>
<div class="para">Le point <span class="process-math">\(Q\)</span> est donné par la formule <span class="process-math">\(\vecl{OQ}=\vecl{OP}-\vecl{AP}_{\vec{n}}\text{.}\)</span> On obtient alors:</div>
<figure class="listing figure-like"><div class="code-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><pre class="program"><code class="language-py">OQ=OP-APsurn
show(OQ)
</code></pre></div>
<figcaption><span class="type">Bloc de code</span><span class="space"> </span><span class="codenumber">1.3.34<span class="period">.</span></span><span class="space"> </span>Les coordonnées du points <span class="process-math">\(Q\)</span></figcaption></figure>
</li>
<li>
<div class="para">Pour illustrer le plan, le point <span class="process-math">\(P\)</span> et le vecteur <span class="process-math">\(\vecl{AP}_{\vec{n}}\text{,}\)</span> on utilise:</div>
<figure class="listing figure-like"><div class="code-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><pre class="program"><code class="language-py">plan=implicit_plot3d(n*vector([x-6,y-3,z-2])==0,(x,-10,10),(y,-10,10),(z,-10,10),color="blue")
P=point(OP,size=15,color="black")
vecproj=plot(APsurn,color="red",start=OQ)
plan+P+vecproj
</code></pre></div>
<figcaption><span class="type">Bloc de code</span><span class="space"> </span><span class="codenumber">1.3.35<span class="period">.</span></span><span class="space"> </span>Le code de la représentation graphique</figcaption></figure>
</li>
</ol></div>
<span class="incontext"><a href="sec-droitesplans.html#p-836" class="internal">Contexte</a></span>
</body>
</html>
