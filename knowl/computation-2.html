<!DOCTYPE html>
<html lang="fr-CA">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
<script>// Make *any* pre with class 'sagecell-sage' an executable Sage cell
// Their results will be linked, only within language type
sagecell.makeSagecell({inputLocation: 'pre.sagecell-sage',
                       linked: true,
                       languages: ['sage'],
                       evalButtonText: 'Évaluer (Sage)'});
</script>
</head>
<body class="ignore-math">
<article class="computation computation-like"><h4 class="heading">
<span class="type">Calcul</span><span class="space"> </span><span class="codenumber">1.2.12</span><span class="period">.</span><span class="space"> </span><span class="title">Géométrie de la programmation linéaire avec Sage.</span>
</h4> <div class="para">Sage possède un module pour explorer la programmation linéaire. On y définit les vecteurs <span class="process-math">\(\vec{c},\vec{b}\text{,}\)</span> ainsi que la matrice <span class="process-math">\(A\text{.}\)</span> En principe, il n'est pas obligatoire d'avoir la matrice du problème sous forme canonique, car il est possible de spécifier le type d'inégalité et le type de problème (maximisation ou minimisation). Une fois les vecteurs et la matrice définis, la commande <code class="code-inline tex2jax_ignore">InteractiveLPProblem(A, b, c, ["x", "y"], variable_type="&gt;=")</code> permet de créer la structure du programme linéaire. Les arguments <code class="code-inline tex2jax_ignore">A,b,c</code> sont, dans l'ordre, la matrice des contraintes, le vecteur de ces contraintes et le vecteur des coefficients de la fonction objectif. L'argument <code class="code-inline tex2jax_ignore">["x", "y"]</code> donne le nom aux variables. Finalement l'argument <code class="code-inline tex2jax_ignore">variable_type</code> donne le type d'inégalité, à savoir si les variables doivent être non négatives ou autre chose.</div> <div class="para">Dans un premier temps, on regarde l'exemple d'introduction qui a servi à motiver la sous-section. En ajoutant la ligne <code class="code-inline tex2jax_ignore">%display typeset</code> à la cellule Sage, il est possible de visualiser l'écriture du problème à même sage.</div> <pre class="ptx-sagecell sagecell-sage" id="sage-41"><script type="text/x-sage">A = matrix([[1, 0], [0, 1],[1,1]])
b = vector([8, 5,10])
c = vector([2, 1])
P = InteractiveLPProblem(A, b, c, ["x_1", "x_2"], variable_type=">=")
%display typeset
P
</script></pre> <div class="para">La commande <code class="code-inline tex2jax_ignore">feasible_set</code> permet de visualiser la région admissible (lorsque le nombre de variable est deux ou trois).</div> <pre class="ptx-sagecell sagecell-sage" id="sage-42"><script type="text/x-sage">P.feasible_set()
</script></pre> <div class="para">On peut aussi reproduire la région admissible et les contraintes à l'aide de la commande <code class="code-inline tex2jax_ignore">plot_feasible_set</code>. Cette dernière offre plus de flexibilité quant au secteur qui peut être visualisé et à l'opacité de la région admissible.</div> <pre class="ptx-sagecell sagecell-sage" id="sage-43"><script type="text/x-sage">P.plot_feasible_set(0,10,0,12,alpha=0.9)
</script></pre> <div class="para">On peut obtenir directement les coordonnées des sommets de la région admissible à l'aide de la commande <code class="code-inline tex2jax_ignore">vertices</code>.</div> <pre class="ptx-sagecell sagecell-sage" id="sage-44"><script type="text/x-sage">P.feasible_set().vertices()
</script></pre> <div class="para">Ce format n'est pas pratique pour les calculs puisqu'il contient aussi du texte. On peut extraire les vecteurs à l'aide de la fonction suivante.</div> <pre class="ptx-sagecell sagecell-sage" id="sage-45"><script type="text/x-sage">L=P.feasible_set().vertices()
S=[]
for v in L:
    S.append(v.vector())
S
</script></pre> <div class="para">S contient maintenant la liste des sommets de la région admissible. Comme la fonction objectif est encodée dans le vecteur <span class="process-math">\(\vec{c}\text{,}\)</span> on peut l'évaluer en chacun des points de <code class="code-inline tex2jax_ignore">S</code> à l'aide du produit scalaire.</div> <pre class="ptx-sagecell sagecell-sage" id="sage-46"><script type="text/x-sage">Valeurs=[c*v for v in S] 
Valeurs
</script></pre> <div class="para">Bien entendu, on peut aussi calculer la solution optimale avec une commande.</div> <pre class="ptx-sagecell sagecell-sage" id="sage-47"><script type="text/x-sage">P.optimal_solution()
</script></pre> <div class="para">Sage peut aussi calculer graphiquement la solution. Il illustre quelques-unes des courbes de niveau et indique le maximum sur la graphique avec un flèche noire. Cette flèche, toujours parallèle à la courbe de niveau, indique la direction qui produit la plus grande variation de la fonction. Dans un cours de calcul de fonctions à plusieurs variables, cette direction est celle qui maximise le gradient de la fonction. Cette direction est aussi très utile dans les problèmes d'apprentissage profond.</div> <pre class="ptx-sagecell sagecell-sage" id="sage-48"><script type="text/x-sage"></script></pre> <div class="para">On reprend maintenant l'exemple <a href="" class="xref" data-knowl="./knowl/ex-simplexe4.html" title="Exemple 1.2.7: Minimisation du coût de nutriments">1.2.7</a>, qui n'était pas sous forme canonique. On montre que Sage peut quand même travailler avec cette forme, si on lui spécifie correctement le type de contraintes et de problème. On peut aussi convertir un problème à sa forme canonique.</div> <div class="para">Si on entre les valeurs telles qu'elles sont données dans le problème, sans égard à la forme canonique, on voit rapidement que le programme créé par Sage ne correspond pas à celui que l'on veut résoudre.</div> <pre class="ptx-sagecell sagecell-sage" id="sage-49"><script type="text/x-sage">A = matrix([[3, 2],[2,4], [5, 7],[4,5]])
b = vector([28,30,70,100])
c = vector([4, 5])
P = InteractiveLPProblem(A, b, c, ["p", "q"],  variable_type=">=")
</script></pre> <div class="para">On remédie à cette situation en ajoutant un argument <code class="code-inline tex2jax_ignore">problem_type="max"</code> et un argument <code class="code-inline tex2jax_ignore">constraint_type</code>. Ces arguments permettent à Sage de comprendre que l'on cherche le minimum de la fonction et que les trois premières contraintes sont de type <span class="process-math">\(\geq\text{.}\)</span>
</div> <pre class="ptx-sagecell sagecell-sage" id="sage-50"><script type="text/x-sage">P = InteractiveLPProblem(A, b, c, ["p", "q"], problem_type="min", constraint_type=[">=",">=",">=", "<="], variable_type=">=")
</script></pre> <div class="para">À partir de ce programme corrigé, on peut extraire les mêmes informations qui pour le problème d'introduction.</div> <pre class="ptx-sagecell sagecell-sage" id="sage-51"><script type="text/x-sage">show(P.feasible_set())
show(P.plot_feasible_set(0,25,0,20,alpha=0.9))
show("Liste des sommets: ",P.feasible_set().vertices())
L=P.feasible_set().vertices()
S=[]
for v in L:
    S.append(v.vector())
Valeurs=[c*v for v in S] 
show("Liste des sommets:", S)
show("La valeur de la fonction à ces sommets:", Valeurs)
show("La valeur optimale trouvée directement par Sage:", P.optimal_solution())
show(P.plot(0,25,0,20,alpha=0.9))
</script></pre> <div class="para">Il est possible d'obtenir la matrice, le vecteur <span class="process-math">\(\vec{b}\)</span> et le vecteur <span class="process-math">\(c\)</span> d'un problème de programmation linéaire.</div> <pre class="ptx-sagecell sagecell-sage" id="sage-52"><script type="text/x-sage">show("A=",P.A())
show("b=",P.b())
show("c=",P.c())
</script></pre> <div class="para">Finalement, la commande <code class="code-inline tex2jax_ignore">standard_form</code> permet de convertir un programme existant en forme canonique. On peut en constater l'effet en regardant la matrice et les vecteurs associés au nouveau programme.</div> <pre class="ptx-sagecell sagecell-sage" id="sage-53"><script type="text/x-sage">P=P.standard_form() #On redifnit P dans sa forme canonique
show("A=",P.A())
show("b=",P.b())
show("c=",P.c())
</script></pre></article><span class="incontext"><a href="sec-simplexe.html#computation-2" class="internal">Contexte</a></span>
</body>
</html>
