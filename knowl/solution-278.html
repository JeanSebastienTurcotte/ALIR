<!DOCTYPE html>
<html lang="fr-CA" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<div class="solution solution-like">
<h6 class="heading">
<span class="type">Solution</span><span class="space"> </span><span class="codenumber">2.4.3.9.c.1</span><span class="period">.</span>
</h6>
<div class="para">Les démarches seront les mêmes, mais on doit ajouter une étape au début. En effet, notre plan est défini par son équation vectorielle. Il faut trouver un vecteur normal pour effectuer nos projections.</div> <figure class="listing figure-like"><div class="code-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><pre class="program"><code class="language-py">var("x,y,z")
v1=vector([-1,2,1])
v2=vector([3,0,-4])
#Le vecteur voulu n est solution des deux équations suivantes puisqu'il est perpendiculaire aux deux vecteurs directeurs en même temps
sol=solve([v1*vector([x,y,z])==0,v2*vector([x,y,z])==0],x,y,z,solution_dict=True) 
show("n=",sol)
#La procédure suivante permet de remplacer la variable libre par une valeur choisie, disons 6 pour éviter les fractions
l=[] #Liste vide des variables libres
for v in sol[0].keys():  # vérifier ce que sol[0].keys() donne pour comprendre cette étape
    for var in sol[0][v].variables():  #Vérifier aussi cette étape
        if var not in l:   #On ne veut pas que les variables soient la plusieurs fois
            l.append(var)
n=vector([sol[0][x],sol[0][y],sol[0][z]]).subs({l[0]:6})
show("n=",n)
</code></pre></div>
<figcaption><span class="type">Bloc de code</span><span class="space"> </span><span class="codenumber">2.4.16<span class="period">.</span></span><span class="space"> </span>Le code solution pour trouver le vecteur normal</figcaption></figure> <div class="para logical">
<div class="para">On considère les trois vecteurs suivants: le vecteur normal <span class="process-math">\(\vec{n}=(8,1,6)\)</span> et deux vecteurs directeurs quelconques <span class="process-math">\(\vec{v}_1=(-1,2,1)\)</span> et <span class="process-math">\(\vec{v}_2=(3,0,-4)\text{.}\)</span> En effet, le vecteur normal sera transformé en son vecteur opposé et les vecteurs directeurs ne bougeront pas puisqu’ils sont dans le plan de réflexion. Ainsi,</div>
<div class="displaymath process-math">
\begin{equation*}
T(\vec{n})=T\vecddd{8}{1}{6}=\vecddd{-8}{-1}{-6}\text{, }T(\vec{v}_1)=T\vecddd{-1}{2}{1}=\vecddd{-1}{2}{1}\text{, }T(\vec{v}_2)=T\vecddd{3}{0}{-4}=\vecddd{3}{0}{-4}
\end{equation*}
</div>
<div class="para">On résume tout cela sous forme matricielle où <span class="process-math">\(U\)</span> est la matrice des vecteurs initiaux et <span class="process-math">\(V\)</span> celle des vecteurs transformés et l’on isole la matrice de <span class="process-math">\(T\text{.}\)</span> On a fait les calculs avec Sage.</div>
</div> <figure class="listing figure-like"><div class="code-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><pre class="program"><code class="language-py">U=matrix([[8,-1,3],[1,2,0],[6,1,-4]])
V=matrix([[-8,-1,3],[-1,2,0],[-6,1,-4]])
Uinv=U.inverse()
show("U=",U)
show("V=",V)
show("U^(-1)=",Uinv)
show("T=",V*Uinv)
</code></pre></div>
<figcaption><span class="type">Bloc de code</span><span class="space"> </span><span class="codenumber">2.4.17<span class="period">.</span></span><span class="space"> </span>Le code solution pour l’exercice</figcaption></figure> <div class="para logical">
<div class="para">La matrice de <span class="process-math">\(T\)</span> est donc:</div>
<div class="displaymath process-math">
\begin{equation*}
T=\begin{pmatrix}-\frac{27}{101}&amp;-\frac{16}{101}&amp;-\frac{96}{101}\\-\frac{16}{101}&amp;\frac{99}{101}&amp;-\frac{12}{101}\\ 
-\frac{96}{101}&amp;-\frac{12}{101}&amp;\frac{29}{101}\end{pmatrix}
\end{equation*}
</div>
</div> <div class="para logical">
<div class="para">Autrement, la projection orthogonale sur le plan pour chaque vecteur s’obtient en considérant d’abord la projection sur le vecteur normal. On avait obtenu la formule:</div>
<div class="displaymath process-math" data-contains-math-knowls="./knowl/eq-projortho.html">
\begin{equation*}
T(\vec{u})=\vec{u}-2\vec{u}_{\vec{n}}
\end{equation*}
</div>
<div class="para">On effectue ensuite tous les calculs sur Sage pour trouver les images des trois vecteurs. On rappelle la formule <a href="" class="xref" data-knowl="./knowl/eq-projortho.html" title="Équation 1.2.5">(1.2.5)</a> pour la projection.</div>
</div> <figure class="listing figure-like"><div class="code-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><pre class="program"><code class="language-py">i=vector([1,0,0])
j=vector([0,1,0])
k=vector([0,0,1])
n=vector([8,1,6])
Ti=i-2*((i*n)/(n*n))*n #la réflexion de (1,0,0) sur le plan, qui utilise la projection orthogonale
Tj=j-2*((j*n)/(n*n))*n
Tk=k-2*((k*n)/(n*n))*n
T=column_matrix([Ti,Tj,Tk]) #on met les résultats en colonnes pour obtenir T
show(T)
</code></pre></div>
<figcaption><span class="type">Bloc de code</span><span class="space"> </span><span class="codenumber">2.4.18<span class="period">.</span></span><span class="space"> </span>Le code solution pour l’exercice</figcaption></figure> <div class="para logical">
<div class="para">La matrice de <span class="process-math">\(T\)</span> est donc bel et bien:</div>
<div class="displaymath process-math">
\begin{equation*}
T=T=\begin{pmatrix}-\frac{27}{101}&amp;-\frac{16}{101}&amp;-\frac{96}{101}\\-\frac{16}{101}&amp;\frac{99}{101}&amp;-\frac{12}{101}\\ 
-\frac{96}{101}&amp;-\frac{12}{101}&amp;\frac{29}{101}\end{pmatrix}
\end{equation*}
</div>
</div>
</div>
<span class="incontext"><a href="sec-transfodimsup.html#solution-278" class="internal">Contexte</a></span>
</body>
</html>
